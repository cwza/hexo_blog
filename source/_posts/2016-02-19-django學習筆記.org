#+TITLE: django學習筆記
#+DATE: <2016-02-19 Fri 16:15>   
#+TAGS: python, django
#+LAYOUT: post
#+CATEGORIES: python
#+OPTIONS: toc:t \n:t ^:{}

django學習筆記
隨筆亂記，陸續增加中
#+BEGIN_HTML
<!--more-->
#+END_HTML

* Layout Django Project
For Example:
icecreamratings project/: git repository root
icecreamratings/: project root
products/, ratings/...etc: app root
#+begin_src sh
icecreamratings_project/
    .gitignore
    Makefile
    docs/
    README.rst
    requirements.txt
    icecreamratings/
        manage.py
        media/  # Development ONLY!
        products/
        profiles/
        ratings/
        static/
        templates/
        config/
            __init__.py
            settings/
            urls.py
            wsgi.py
#+end_src
可參考github上大大寫好的django project layout工具吧
https://github.com/pydanny/cookiecutter-django

* Setting Files
** 如何處理多環境設定(production, staging, local)
將setting files分開成各個環境，所有setting file全部進入git控管
底下為例子，在<repository root>/config/settings
#+begin_src sh
settings/
      __init__.py
      base.py
      dev_audreyr.py
      dev_pydanny.py
      local.py
      staging.py
      test.py
      production.py
#+end_src

local設定繼承自base
#+begin_src python
# settings/local.py 
from .base import *
DEBUG = True

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": "twoscoops",
        "USER": "",
        "PASSWORD": "",
        "HOST": 
        "localhost",
        "PORT": "",
        } 
}

INSTALLED_APPS += ("debug_toolbar", )
#+end_src

個人設定，繼承自local
#+begin_src python
# settings/dev_pydanny.py 
from .local import *
# Set short cache timeout
CACHE_TIMEOUT = 30
#+end_src

執行時用以下方式指定setting file執行
#+begin_src sh
django-admin shell --settings=twoscoops.settings.local
django-admin runserver --settings=twoscoops.settings.local
#+end_src
在server上可以設定環境變數DJANGO SETTINGS MODULE and PYTHONPATH來指定setting file，或利用virtualenv來設定(add Export to the end of virtualenv's bin/activate)
** 重要的secret key問題(secret key不該進入version control)
secret key不該進入version control所以不要把它放在setting file中
最好是放在environment variable，setting file中用os.environ["SOME_SECRET_KEY"]去拿

linux下將以下放到.bashrc, .bash_profile, or .profile
或利用virtualenv來設定(add Export to the end of virtualenv's bin/activate)
#+begin_src sh
export SOME_SECRET_KEY=1c3-cr3am-15-yummy
#+end_src

setting file用以下方式拿secret key
#+begin_src python
# Top of settings/production.py
import os
SOME_SECRET_KEY = os.environ["SOME_SECRET_KEY"]
#+end_src

上述方式在拿不到environ variable時錯誤訊息會是key_error，不甚好，可在base.py中加入以下改良
#+begin_src python
# settings/base.py 
import os
# Normally you should not import ANYTHING from Django directly
# into your settings, but ImproperlyConfigured is an exception.
from django.core.exceptions import ImproperlyConfigured .
def get_env_variable(var_name):
    """Get the environment variable or return exception.""" 
    try:
        return os.environ[var_name] 
    except KeyError:
        error_msg = "Set the {} environment variable".format(var_name)
        raise ImproperlyConfigured(erro.r_msg)
#+end_src

#+begin_src python
SOME_SECRET_KEY = get_env_variable("SOME_SECRET_KEY")
#+end_src
** 當環境限制無法使用environment variable時怎麼做呢
將secret_key放進json file(or xml, yml ...etc)，setting file中利用json util將secret_key讀出，注意此secret file不該進入version control
#+begin_src javascript
{
    "FILENAME": "secrets.json",
    "SECRET_KEY": "I've got a secret!",
    "DATABASES_HOST": "127.0.0.1",
    "PORT": "5432"
}
#+end_src

#+begin_src python
# settings/base.py
import json
# Normally you should not import ANYTHING from Django directly # into your settings, but ImproperlyConfigured is an exception. from django.core.exceptions import ImproperlyConfigured

# JSON-based secrets module

with open("secrets.json") as f:
    secrets = json.loads(f.read())
def get_secret(setting, secrets=secrets):
    """Get the secret variable or return explicit exception."""
    try:
        return secrets[setting] 
    except KeyError:
        error_msg = "Set the {0} environment variable".format(setting) 
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_secret("SECRET_KEY")
#+end_src

** Requirements Files也要照環境分開
不同環境可能需要裝不同package(ex: local才需要debug工具)
在<repository root>/requirements
#+begin_src sh
requirements/
    base.txt
    local.txt
    staging.txt
    production.txt
#+end_src

in base.txt
#+begin_src python
Django==1.8.0
psycopg2==2.6
djangorestframework==3.1.1
#+end_src

in local.txt
#+begin_src python
-r base.txt # includes the base.txt requirements file

coverage==3.7.1
django-debug-toolbar==1.3.0
#+end_src

in production.txt
#+begin_src python
-r base.txt # includes the base.txt requirements file
#+end_src

裝package時用以下指令指定requirements檔案安裝
#+begin_src sh
$ pip install -r requirements/local.txt
$ pip install -r requirements/production.txt
#+end_src
** Setting Files中的Path不要使用Absolute Path
利用Unipath (http://pypi.python.org/pypi/Unipath/)
#+begin_src python
# At the top of settings/base.py 
from unipath import Path

BASE_DIR = Path(__file__).ancestor(3)
MEDIA_ROOT = BASE_DIR.child("media")
STATIC_ROOT = BASE_DIR.child("static")
STATICFILES_DIRS = (
    BASE_DIR.child("assets"),
)
TEMPLATES = [
    {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         DIRS = (BASE_DIR.child("templates"),)
     },
]
#+end_src

或用python內建的os.path
#+begin_src python
# At the top of settings/base.py
from os.path import join, abspath, dirname
here = lambda *dirs: join(abspath(dirname(__file__)), *dirs) BASE_DIR = here("..", "..")
root = lambda *dirs: join(abspath(BASE_DIR), *dirs)

# Configuring MEDIA_ROOT
MEDIA_ROOT = root("media")

# Configuring STATIC_ROOT
STATIC_ROOT = root("collected_static")

# Additional locations of static files
STATICFILES_DIRS = (
    root("assets"),
)

# Configuring TEMPLATE_DIRS
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        DIRS = (root("templates"),)
    }, 
]
#+end_src
* Model
** Model Inheritance
當重複field太多時，可考慮abstract base inheritance，例如幾乎每個model都要有created, modified
+ Abstract base classes: 實際上DB不會有parent table
+ multi-table inheritance: DB確實會長出parent table and child table然後用foreign key連結
+ proxy models

*不要使用multi-table inheritance，由於其實是使用foreign key處理所以會有效能問題*

以下為例子
core.models.TimeStampedModel裡有常用的created and modified field
flavors.Flovor繼承TimeStampedModel的field
注意
    class Meta: 
        abstract = True
#+begin_src python
# core/models.py
from django.db import models
class TimeStampedModel(models.Model): 
    """
    An abstract base class model that provides self-
    updating ``created`` and ``modified`` fields.
    """
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)

    class Meta: 
        abstract = True
#+end_src
#+begin_src python
# flavors/models.py
from django.db import models
from core.models import TimeStampedModel

class Flavor(TimeStampedModel):
    title = models.CharField(max_length=200)
#+end_src
** Model Design Ordering
1. Start Normalized
2. Cache Before Denormalizing
3. Denormalize Only if Absolutely Needed(try cache, row SQL, indexes)
** When to Use Null and Blank
[[{% asset_img table6_2.png %}]]
** When to Use BinaryField
*Don't Serve Files From BinaryField. Use FileField!!!*
+ MessagePack-formatted content.
+ Raw sensor data.
+ Compressed data e.g. the type of data Sentry stores as a BLOB, but is required to base64-encode due to legacy issues.
** Try to Avoid Using Generic Relations
Cons:
+ Reduction in speed of queries due to lack of indexing between models.
+ Danger of data corruption as a table can refer to another against a non-existent record.
So:
+ Try to avoid generic relations and GenericForeignKey.
+ If you think you need generic relations, see if the problem can be solved through better model design or the new PostgreSQL  elds.
+ If usage can’t be avoided, try to use an existing third-party app.  e isolation a third-party app provides will help keep data cleaner.
** The Model meta API
Main Usages:
+ Get a list of a model’s fields.
+ Get the class of a particular  eld for a model (or its inheritance chain or other info derived from such).
+ Ensure that how you get this information remains constant across future Django versions.

Examples:
+ Building a Django model introspection tool.
+ Building your own custom specialized Django form library.
+ Creating admin-like tools to edit or interact with Django model data.
+ Writing visualization or analysis libraries, e.g. analyzing info only about  elds that start with “foo”.
** Fat Models
將跟DB有關的邏輯從view中抽出放到Model中包裝是好的設計，但project到最後會發生Model肥大的問題，一個Model數千行這就不好了，底下提供兩個解法
+ Model Behaviors Pattern: http://blog.kevinastone.com/django-model-behaviors.html
+ Mixin
* Queries and the Database Layer
** Use get object or 404() for Single Objects instead of get()
+ Only use it in views.
+ Don’t use it in helper functions, forms, model methods or anything that is not a view or directly view related.
** Be Careful With Queries That Might Throw Exceptions
*** ObjectDoesNotExist vs. DoesNotExist
ObjectDoesNotExist can be applied to any model object, whereas DoesNotExist is for a speci c model.
#+begin_src python
from django.core.exceptions import ObjectDoesNotExist 
from flavors.models import Flavor
from store.exceptions import OutOfStock

def list_flavor_line_item(sku): 
    try:
        return Flavor.objects.get(sku=sku, quantity__gt=0)
    except Flavor.DoesNotExist:
        msg = "We are out of {0}".format(sku) 
        raise OutOfStock(msg)
def list_any_line_item(model, sku): 
    try:
        return model.objects.get(sku=sku, quantity__gt=0) 
    except ObjectDoesNotExist:
        msg = "We are out of {0}".format(sku) 
        raise OutOfStock(msg)
#+end_src
*** When You Just Want One Object but Get Three Back
check for a MultipleObjectsRe- turned exception
#+begin_src python
from flavors.models import Flavor
from store.exceptions import OutOfStock, CorruptedDatabase

def list_flavor_line_item(sku): 
    try:
        return Flavor.objects.get(sku=sku, quantity__gt=0) .
    except Flavor.DoesNotExist:
        msg = "We are out of {}".format(sku) 
        raise OutOfStock(msg)
    except Flavor.MultipleObjectsReturned:
        msg = "Multiple items have SKU {}. Please fix!".format(sku) 
        raise CorruptedDatabase(msg)
#+end_src
** Transactions
*** Wrapping Each HTTP Request in a Transaction
#+begin_src python
# settings/base.py
DATABASES = {
'default': {
        # ...
        'ATOMIC_REQUESTS': True,
        },
}
#+end_src

non atomic function include atomic code:
#+begin_src python
# flavors/views.py
from django.db import transaction
from django.http import HttpResponse
from django.shortcuts import get_object_or_404 
from django.utils import timezone
from .models import Flavor

@transaction.non_atomic_requests
def posting_flavor_status(request, pk, status):
    flavor = get_object_or_404(Flavor, pk=pk)

    # This will execute in autocommit mode (Django's default).
    flavor.latest_status_change_attempt = timezone.now()
    flavor.save()

    with transaction.atomic():
    # This code executes inside a transaction. 
        flavor.status = status 
        flavor.latest_status_
        change_success = timezone.now() 
        flavor.save()
        return HttpResponse("Hooray")

    # If the transaction fails, return the appropriate status 
    return HttpResponse("Sadness", status_code=400)

#+end_src
*** Explicit Transaction Declaration
* Function- and Class-Based Views
** When to Use FBVs or CBVs
[[{% asset_img figure8_1.png %}]]
** Keep View Logic Out of URLConfs
Bad Example:
#+begin_src python
from django.conf.urls import url
from django.views.generic import DetailView
from tastings.models import Tasting

urlpatterns = [ 
    url(r"ˆ(?P<pk>\d+)/$",
        DetailView.as_view(
            model=Tasting,
            template_name="tastings/detail.html"),
        name="detail"),
    url(r"ˆ(?P<pk>\d+)/results/$", 
        DetailView.as_view(
            model=Tasting,
            template_name="tastings/results.html"),
        name="results"),
]

#+end_src

Good view example:
#+begin_src python
# tastings/views.py
from django.views.generic import ListView, DetailView, UpdateView 
from django.core.urlresolvers import reverse
from .models import Tasting 

class TasteListView(ListView):
    model = Tasting
class TasteDetailView(DetailView):
    model = Tasting
class TasteResultsView(TasteDetailView):
    template_name = "tastings/results.html"
class TasteUpdateView(UpdateView): 
    model = Tasting
    def get_success_url(self):
        return reverse("tastings:detail",
            kwargs={"pk": self.object.pk})
#+end_src

Good urls example:
#+begin_src python
# tastings/urls.py
from django.conf.urls import url
from . import views

urlpatterns = [
    url(
        regex=r"ˆ$", 
        view=views.TasteListView.as_view(), 
        name="list"
    ),
    url(
        regex=r"ˆ(?P<pk>\d+)/$", 
        view=views.TasteDetailView.as_view(), 
        name="detail"
    ), 
    url(
        regex=r"ˆ(?P<pk>\d+)/results/$", 
        view=views.TasteResultsView.as_.view(), 
        name="results"
    ), 
    url(
        regex=r"ˆ(?P<pk>\d+)/update/$", 
        view=views.TasteUpdateView.as_view(), 
        name="update"
    ) 
]
#+end_src
** Use URL Namespaces
In the root URLConf we would add:
#+begin_src python
# urls.py at root of project
urlpatterns += [
    url(r'ˆtastings/', include('tastings.urls', namespace='tastings')),
]
#+end_src

view example:
#+begin_src python
# tastings/views.py snippet
class TasteUpdateView(UpdateView):
    model = Tasting
    def get_success_url(self):
        return reverse("tastings:detail", .
            kwargs={"pk": self.object.pk})
#+end_src

template example:
{% raw %}
#+begin_src python
{% extends "base.html" %}
{% block title %}Tastings{% endblock title %}
{% block content %}
<ul>
  {% for taste in tastings %} 
    <li>
      <a href="{% url "tastings:detail" taste.pk %}">{{ taste.title }}</a>
      <small>
        (<a href="{% url "tastings:update" taste.pk %}">update</a>)
      </small>
    </li>
  {% endfor %}
</ul>
{% endblock content %}
#+end_src
{% endraw %}
** Django Views Are Functions
Class-Based Views Are Actually Called as Functions
#+begin_src python
# simplest_views.py
from django.http import HttpResponse 
from django.views.generic import View

# The simplest FBV
def simplest_view(request):
    # Business logic goes here 
    return HttpResponse("FBV")

# The simplest CBV
class SimplestView(View):
    def get(self, request, *args, **kwargs):
       # Business logic goes here
       return HttpResponse("CBV")
#+end_src
** Don't Use locals() as Views Context
Bad example:
#+begin_src python
def ice_cream_store_display(request, store_id): 
    store = get_object_or_404(Store, id=store_id)
    now = timezone.now()
    return render(request, 'melted_ice_cream_report.html', locals())
#+end_src

Good example:
#+begin_src python
def ice_cream_store_display(request, store_id):
    return render(request, 'melted_ice_cream_report.html', dict{
        'store': get_object_or_404(Store, id=store_id),
        'now': timezone.now()
    })
#+end_src
* Function-Based Views
** Use Decorator To Modify Request And Response
Here’s a sample decorator template for use in function-based views:
functools.wraps() is a convenience tool that copies over metadata including critical data like docstrings to the newly decorated function.
#+begin_src python
# simple decorator template import functools
def decorator(view_func): 
    @functools.wraps(view_func)
    def new_view_func(request, *args, **kwargs):
        # You can modify the request (HttpRequest) object here. 
        response = view_func(request, *args, **kwargs)
        # You can modify the response (HttpResponse) object here. 
        return response
    return new_view_func
#+end_src

check_sprinkles is a decorator to modify request:
#+begin_src python
# sprinkles/decorators.py 
from functools import wraps
from . import utils

# based off the decorator template from Example 8.5 
def check_sprinkles(view_func):
"""Check if a user can add sprinkles""" 
    @wraps(view_func)
    def new_view_func(request, *args, **kwargs):
        # Act on the request object with utils.can_sprinkle()
        request = utils.can_sprinkle(request)
        # Call the view function
        response = view_func(request, *args, **kwargs)
        # Return the HttpResponse object
        return response 
    return new_view_func
#+end_src

Then we attach it to the function thus:
#+begin_src python
# views.py
from django.shortcuts import get_object_or_404, render
from .decorators import check_sprinkles
from .models import Sprinkle

# Attach the decorator to the view 
@check_sprinkles
def sprinkle_detail(request, pk):
    """Standard detail view"""
    sprinkle = get_object_or_404(Sprinkle, pk=pk)
    return render(request, "sprinkles/sprinkle_detail.html",
        {"sprinkle": sprinkle})
#+end_src
* Class-Based Views
** Guidelines When Working With CBVs
+ Less view code is better.
+ Never repeat code in views.
+ Views should handle presentation logic. Try to keep business logic in models when possible, or in forms if you must.
+ Keep your views simple.
+ Don’t use CBVs to write custom 403, 404, and 500 error handlers. Use FBVs instead.
+ Keep your mixins simpler.
** Using Mixins With CBVs
The rules follow Python’s method resolution order, which in the most simplistic de nition possible, proceeds from left to right:
1. The base view classes provided by Django always go to the right.
2. Mixins go to the left of the base view.
3. Mixins should inherit from Python’s built-in object type.

Example of the rules in action:
#+begin_src python
from django.views.generic import TemplateView 

class FreshFruitMixin(object):
    def get_context_data(self, **kwargs): 
        context = super(FreshFruitMixin,
            . self).get_context_data(**kwargs)
        context["has_fresh_fruit"] = True 
        return context

class FruityFlavorView(FreshFruitMixin, TemplateView): 
    template_name = "fruity_flavor.html"
#+end_src
** Which Django GCBV Should Be Used for What Task?
[[{% asset_img table10_1.png %}]]
** General Tips for Django CBVs
*** Constraining Django CBV/GCBV Access to Authenticated Users
Use django-braces LoginRequiredMixin
#+begin_src python
# flavors/views.py
from django.views.generic import DetailView
from braces.views import LoginRequiredMixin
from .models import Flavor

class FlavorDetailView(LoginRequiredMixin, DetailView):
    model = Flavor
#+end_src
*** Performing Custom Actions on Views With Valid Forms
#+begin_src python
from django.views.generic import CreateView 
from braces.views import LoginRequiredMixin 
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    def form_valid(self, form):
        # Do custom logic here
        return super(FlavorCreateView, self).form_valid(form)
#+end_src
To perform custom logic on form data that has already been validated, simply add the logic to formvalid().  e return value of formvalid() should be a django.http.HttpResponseRedirect.
*** Performing Custom Actions on Views With Invalid Forms
#+begin_src python
from django.views.generic import CreateView 
from braces.views import LoginRequiredMixin
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView): 
    model = Flavor
    def form_invalid(self, form):
    # Do custom logic here .
        return super(FlavorCreateView, self).form_invalid(form)
#+end_src
*** Using the View Object
If you are using class-based views for rendering content, consider using the view object itself to provide access to properties and methods that can be called by other method and properties.  ey can also be called from templates. For example:
#+begin_src python
from django.utils.functional import cached_property
from django.views.generic import UpdateView, TemplateView
from braces.views import LoginRequiredMixin 
from .models import Flavor
from .tasks import update_users_who_favorited 

class FavoriteMixin(object):
    @cached_property
    def likes_and_favorites(self):
    """Returns a dictionary of likes and favorites""" 
    likes = self.object.likes()
    favorites = self.object.favorites()
    return {
        "likes": likes,
        "favorites": favorites,
        "favorites_count": favorites.count(),
    }
class FlavorUpdateView(LoginRequiredMixin, FavoriteMixin, UpdateView): 
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    def form_valid(self, form): 
        update_users_who_favorited(
            instance=self.object,
            favorites=self.likes_and_favorites['favorites']
        )
        return super(FlavorCreateView, self).form_valid(form)
class FlavorDetailView(LoginRequiredMixin, FavoriteMixin, TemplateView): 
    model = Flavor
#+end_src

The nice thing about this is the various  avors/ app templates can now access this property:
{% raw %}
#+begin_src python
{# flavors/base.html #}
{% extends "base.html" %}

{% block likes_and_favorites %} 
  <ul>
    <li>Likes: {{ view.likes_and_favorites.likes }}</li>
    <li>Favorites: {{ view.likes_and_favorites.favorites_count }}</li> 
  </ul>
{% endblock likes_and_favorites %}
#+end_src
{% endraw %}
** How GCBVs and Forms Fit Together
First, let’s define a flavor model to use in this section’s view examples:
#+begin_src python
# flavors/models.py
from django.core.urlresolvers import reverse 
from django.db import models
STATUS = (
    (0, "zero"),
    (1, "one"),
)

class Flavor(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)
    scoops_remaining = models.IntegerField(default=0, choices=STATUS)
    def get_absolute_url(self):
        return reverse("flavors:detail", kwargs={"slug": self.slug})
#+end_src
*** Views + ModelForm Example
Here we have the following views:
1. FlavorCreateView corresponds to a form for adding new flavors.
2. FlavorUpdateView corresponds to a form for editing existing flavors.
3. FlavorDetailView corresponds to the con rmation page for both  avor creation and flavor updates.
Views:
#+begin_src python
# flavors/views.py
from django.contrib import messages
from django.views.generic import CreateView, UpdateView, DetailView
from braces.views import LoginRequiredMixin 
from .models import Flavor

class FlavorActionMixin(object):
    fields = ('title', 'slug', 'scoops_remaining')
    @property
    def success_msg(self):
        return NotImplemented

    def form_valid(self, form):
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)

class FlavorCreateView(LoginRequiredMixin, FlavorActionMixin, CreateView):
    model = Flavor
    success_msg = "Flavor created!"
class FlavorUpdateView(LoginRequiredMixin, FlavorActionMixin, UpdateView):
    model = Flavor
    success_msg = "Flavor updated!"
class FlavorDetailView(DetailView):
    model = Flavor
#+end_src

Template:
{% raw %}
#+begin_src python
{# templates/flavors/flavor_detail.html #}
{% if messages %}
  <ul class="messages">
    {% for message in messages %}
    <li id="message_{{ forloop.counter }}"
        {% if message.tags %} class="{{ message.tags }}" .
          {% endif %}>
        {{ message }}
    </li>
    {% endfor %} 
  </ul>
{% endif %}
#+end_src
{% endraw %}
*** Views + Form Example
Implemente flavor search page
We add the following code to flavors/views.py:
#+begin_src python
from django.views.generic import ListView
from .models import Flavor

class FlavorListView(ListView): 
    model = Flavor
    def get_queryset(self):
    # Fetch the queryset from the parent get_queryset
        queryset = super(FlavorListView, self).get_queryset()

        # Get the q GET parameter
        q = self.request.GET.get("q") 
        if q:
            # Return a filtered queryset
            return queryset.filter(title__icontains=q) 
        # Return the base queryset
        return queryset
#+end_src

Template:
{% raw %}
#+begin_src python
{# templates/flavors/_flavor_search.html #}
{% comment %}
  Usage: {% include "flavors/_flavor_search.html" %}
{% endcomment %}
<form action="{% url "flavor_list" %}" .method="GET">
  <input type="text" name="q" />
  <button type="submit">search</button> 
</form>
#+end_src
{% endraw %}
** Using Just django.views.generic.View
What we find really useful, even on projects which use a lot of generic class-based views, is using the django.views.generic.View class with a GET method for displaying JSON, PDF or other non-HTML content. All the tricks that we’ve used for rendering CSV, Excel, and PDF  les in function-based views apply when using the GET method. For example:

#+begin_src python
from django.http import HttpResponse .
from django.shortcuts import get_object_or_404
from django.views.generic import View
from braces.views import LoginRequiredMixin
from .models import Flavor
from .reports import make_flavor_pdf

class PDFFlavorView(LoginRequiredMixin, View): 
    # Get the flavor
    def get(self, request, *args, **kwargs):
        flavor = get_object_or_404(Flavor, slug=kwargs['slug'])
        # create the response
        response = HttpResponse(content_type='application/pdf')
        # generate the PDF stream and attach to the response
        response = make_flavor_pdf(response, flavor)
        return response
#+end_src
* Form Fundamentals
** Validate All Incoming Data With Django Forms
舉個input data為csv file的例子
Bad Example: 
#+begin_src python
import csv import StringIO
from .models import Purchase 

def add_csv_purchases(rows):
    rows = StringIO.StringIO(rows)
    records_added = 0
    # Generate a dict per row, with the first CSV row being the keys 
    for row in csv.DictReader(rows, delimiter=","):
        # DON'T DO THIS: Tossing unvalidated data into your model.
        Purchase.objects.create(**row)
        records_added += 1
    return records_added
#+end_src
以上Bad example在Purchase create前需要自己寫input data驗證code

Good Example:
#+begin_src python
import csv import StringIO
from django import forms
from .models import Purchase, Seller 

class PurchaseForm(forms.ModelForm):
    class Meta:
        model = Purchase
    def clean_seller(self):
        seller = self.cleaned_data["seller"] 
        try:
            Seller.objects.get(name=seller) 
        except Seller.DoesNotExist:
            msg = "{0} does not exist in purchase #{1}.".format(
                seller,
                self.cleaned_data["purchase_number"]
            )
        raise forms.ValidationError(msg) return seller

def add_csv_purchases(rows):
    rows = StringIO.StringIO(rows)
    records_added = 0
    errors = []
    # Generate a dict per row, with the first CSV row being the k
    for row in csv.DictReader(rows, delimiter=","):
        # Bind the row data to the PurchaseForm. 
        form = PurchaseForm(row)
        # Check to see if the row data is valid. 
        if form.is_valid():
            # Row data is valid so save the record.
            form.save()
            records_added += 1
        else: 
            errors.append(form.errors)
    return recordded, errors
#+end_src
利用django ModelForm的is_valid來做input驗證
** Always Use CSRF Protection and POST With HTTP Forms That Modify Data
You should use Django’s CsrfViewMiddleware as blanket protection across your site rather than manually decorating views with csrf protect.
You should use Django’s CSRF protection even when posting data via AJAX.
** Understand How to Add Django Form Instance Attributes
Inserting the request.user object into forms
form:
#+begin_src python
from django import forms
from .models import Taster
class TasterForm(forms.ModelForm):
    class Meta:
        model = Taster

    def __init__(self, *args, **kwargs):
        # set the user as an attribute of the form 
        self.user = kwargs.pop('user')
        super(TasterForm, self).__init__(*args, **kwargs)
#+end_src

view:
#+begin_src python
from django.views.generic import UpdateView 
from braces.views import LoginRequiredMixin
from .forms import TasterForm 
from .models import Taster

class TasterUpdateView(LoginRequiredMixin, UpdateView): 
    model = Taster
    form_class = TasterForm
    success_url = "/someplace/"
    def get_form_kwargs(self):
        """This method is what injects forms with their keyword arguments.""" 
        # grab the current set of form #kwargs
        kwargs = super(TasterUpdateView, self).get_form_kwargs()
        # Update the kwargs with the user_id
        kwargs['user'] = self.request.user
        return kwargs
#+end_src
** Know How Form Validation Works
Form validation workflow:
+ If the form has bound data, form.is valid() calls the form.full clean() method.
+ form.fullclean() iterates through the form fields and each field validates itself:
  - Data coming into the  eld is coerced into Python via the to python() method or raises a ValidationError.
  - Data is validated against  eld-speci c rules, including custom validators. Failure raises a ValidationError.
  - If there are any custom clean <field>() methods in the form, they are called at this time.
+ form.fullclean() executes the form.clean() method.
+ If it’s a ModelForm instance, form. post clean() does the following:
  - Sets ModelForm data to the Model instance, regardless of whether form.is valid() is True or False.
  - Calls the model’s clean() method. For reference, saving a model instance through the ORM does not call the model’s clean() method.
*** ModelForm Data Is Saved to the Form, Then the Model In- stance
In a ModelForm, form data is saved in two distinct steps:
1. First, form data is saved to the form instance.
2. Later, form data is saved to the model instance.

For example, perhaps you need to catch the details of failed submission attempts for a form, saving both the user-supplied form data as well as the intended model instance changes.

#+begin_src python
# core/models.py
from django.db import models

class ModelFormFailureHistory(models.Model):
    form_data = models.TextField()
    model_data = models.TextField()
#+end_src

#+begin_src python
# flavors/views.py import json
from django.contrib import messages 
from django.core import serializers
from core.models import ModelFormFailureHistory 

class FlavorActionMixin(object):
    @property
    def success_msg(self):
        return NotImplemented
    def form_valid(self, form):
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)
    def form_invalid(self, form):
        """Save invalid form and model data for later reference.""" 
        form_data = json.dumps(form.cleaned_data)
        model_data = serializers.serialize("json",
                    [form.instance])[1:-1]
        ModelFormFailureHistory.objects.create(
            form_data=form_data,
            model_data=model_data
        )
        return super(FlavorActionMixin, self).form_invalid(form)
#+end_src
** Add Errors to Forms with Form.add error()
We can streamline Form.clean() with the Form.add error() method.
#+begin_src python
from django import forms
class IceCreamReviewForm(forms.Form): 
    # Rest of tester form goes here ...
    def clean(self):
        cleaned_data = super(TasterForm, self).clean()
        flavor = cleaned_data.get("flavor")
        age = cleaned_data.get("age")
        if flavor == 'coffee' and age < 3:
            # Record errors that will be displayed later. 
            msg = u"Coffee Ice Cream is not for Babies." 
            self.add_error('flavor', msg) 
            self.add_error('age', msg)
        # Always return the full collection of cleaned data. 
        return cleaned_data
#+end_src
* Common Patterns for Forms
** Pattern 1: Simple ModelForm With Default Validators
#+begin_src python
# flavors/views.py
from django.views.generic import CreateView, UpdateView
from braces.views import LoginRequiredMixin
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
class FlavorUpdateView(LoginRequiredMixin, UpdateView): 
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
#+end_src
+ FlavorCreateView and FlavorUpdateView are assigned Flavor as their model.
+ Both views auto-generate a ModelForm based on the Flavor model.
+ Those ModelForms rely on the default field validation rules of the Flavor model.
** Pattern 2: Custom Form Field Validators in ModelForms
write validator:
#+begin_src python
# core/validators.py
from django.core.exceptions import ValidationError
def validate_tasty(value):
    """Raise a ValidationError if the value doesn't start with the word 'Tasty'."""
    if not value.startswith(u"Tasty"): 
        msg = u"Must start with Tasty" 
        raise ValidationError(msg)
#+end_src
In Django, a custom field validator is simply a function that raises an error if the submitted argument doesn’t pass its test.

validator可以加在兩個地方
*** put validator in Model
#+begin_src python
# core/models.py
from django.db import models
from .validators import validate_tasty 

class TastyTitleAbstractModel(models.Model):
    title = models.CharField(max_length=255, validators=[validate_tasty])
    class Meta: 
        abstract = True
#+end_src
#+begin_src python
# flavors/models.py
from django.core.urlresolvers import reverse 
from django.db import models
from core.models import TastyTitleAbstractModel .

class Flavor(TastyTitleAbstractModel):
    slug = models.SlugField()
    scoops_remaining = models.IntegerField(default=0)
    def get_absolute_url(self):
        return reverse("flavors:detail", kwargs={"slug": self.slug})
#+end_src
*** put validator in Form
#+begin_src python
# flavors/forms.py
from django import forms
from core.validators import validate_tasty from .models import Flavor

class FlavorForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super(FlavorForm, self).__init__(*args, **kwargs)
        self.fields["title"].validators.append(validate_tasty)
        self.fields["slug"].validators.append(validate_tasty)
    class Meta:
        model = Flavor
#+end_src
#+begin_src python
# flavors/views.py
from django.contrib import messages
from django.views.generic import CreateView, UpdateView, DetailView
from braces.views import LoginRequiredMixin 
from .models import Flavor
from .forms import FlavorForm 

class FlavorActionMixin(object):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    @property
    def success_msg(self):
        return NotImplemented
    def form_valid(self, form): 
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)
class FlavorCreateView(LoginRequiredMixin, FlavorActionMixin, CreateView):
    success_msg = "created"
    # Explicitly attach the FlavorForm class
    form_class = FlavorForm
class FlavorUpdateView(LoginRequiredMixin, FlavorActionMixin, UpdateView):
    success_msg = "updated"
    # Explicitly attach the FlavorForm class
    form_class = FlavorForm
class FlavorDetailView(DetailView): 
    model = Flavor
#+end_src
** Pattern 3: Overriding the Clean Stage of Validation
use cases:
+ Multi-field validation
+ Validation involving existing data from the database that has already been validate

Django provides a second stage and process for validating incoming data, this time via the clean() method and clean <field name>() methods.
+ clean() validate two or more fields against each other.
+ clean <field name>() validate against persistent data.

Example:
clean slug(): prevent users from ordering flavors that are out of stock
clean(): validate the flavor and toppings fields against each other
#+begin_src python
# flavors/forms.py
from django import forms
from flavors.models import Flavor

class IceCreamOrderForm(forms.Form):
    """Normally done with forms.ModelForm. But we use forms.Form here
        to demonstrate that these sorts of techniques work on every
        type of form.
    """
    slug = forms.ChoiceField("Flavor")
    toppings = forms.CharField()

    def __init__(self, *args, **kwargs): 
        super(IceCreamOrderForm, self).__init__(*args,
                **kwargs)
        # We dynamically set the choices here rather than
        # in the flavor field definition. Setting them in
        # the field definition means status updates won't
        # be reflected in the form without server restarts.
        self.fields["slug"].choices = [
            (x.slug, x.title) for x in Flavor.objects.all() 
        ]
        # NOTE: We could filter by whether or not a flavor
        #       has any scoops, but this is an example of
        #       how to use clean_slug, not filter().

    def clean_slug(self):
        slug = self.cleaned_data["slug"]
        if Flavor.objects.get(slug=slug).scoops_remaining <= 0:
            msg = u"Sorry, we are out of that flavor."
            raise forms.ValidationError(msg) 
        return slug

    def clean(self):
        cleaned_data = super(IceCreamOrderForm, self).clean()
        slug = cleaned_data.get("slug", "")
        toppings = cleaned_data.get("toppings", "")
        # Silly "too much chocolate" validation example
        if u"chocolate" in slug.lower() and \ u"chocolate" in toppings.lower():
            msg = u"Your order has too much chocolate."
            raise forms.ValidationError(msg) return cleaned_data
#+end_src
** Pattern 4: Hacking Form Fields (2 CBVs, 2 Forms, 1 Model)
example:
IceCreamStore在create時只需要填入title, address，update時再強制其補上phone, description

IceCreamStore Model:
#+begin_src python
from django.core.urlresolvers import reverse 
from django.db import models

class IceCreamStore(models.Model):
    title = models.CharField(max_length=100) 
    block_address = models.TextField() .
    phone = models.CharField(max_length=20, blank=True) 
    description = models.TextField(blank=True)

    def get_absolute_url(self):
        return reverse("store_detail", kwargs={"pk": self.pk})
#+end_src

First we see the bad approach:
#+begin_src python
# stores/forms.py
from django import forms
from .models import IceCreamStore

class IceCreamStoreUpdateForm(forms.ModelForm):
    # Don't do this! Duplication of the model field!
    phone = forms.CharField(required=True)
    # Don't do this! Duplication of the model field!
    description = forms.TextField(required=True)

    class Meta:
    model = IceCreamStore
#+end_src
上面的方法幾乎是copy了model中的field，想像一下若我們需要在description中加入help text，就必須同時在model與form中同時加上不然沒有作用，這不是一個好的設計

Now we use form.fields[].required to do this.
Form:
#+begin_src python
# stores/forms.py
from django import forms
from .models import IceCreamStore

class IceCreamStoreCreateForm(forms.ModelForm):
    class Meta:
        model = IceCreamStore
        fields = ("title", "block_address", )

class IceCreamStoreUpdateForm(IceCreamStoreCreateForm):
    def __init__(self, *args, **kwargs): 
        super(IceCreamStoreUpdateForm,
                self).__init__(*args, **kwargs)
        self.fields["phone"].required = True
        self.fields["description"].required = True
    class Meta(IceCreamStoreCreateForm.Meta):
        # show all the fields!
        fields = ("title", "block_address", "phone", "description", )
#+end_src
Views:
#+begin_src python
# stores/views
from django.views.generic import CreateView, UpdateView
from .forms import IceCreamStoreCreateForm 
from .forms import IceCreamStoreUpdateForm 
from .models import IceCreamStore

class IceCreamCreateView(CreateView):
    model = IceCreamStore
    form_class = IceCreamStoreCreateForm

class IceCreamUpdateView(UpdateView): 
    model = IceCreamStore
    form_class = IceCreamStoreUpdateForm
#+end_src
** Pattern 5: Reusable Search Mixin View
In this example, we’re going to cover how to reuse a search form in two views that correspond to two different models.
simple search mixin for our view:
#+begin_src python
# core/views.py
class TitleSearchMixin(object):

    def get_queryset(self):
        # Fetch the queryset from the parent's get_queryset 
        queryset = super(TitleSearchMixin, self).get_queryset()
        # Get the q GET parameter
        q = self.request.GET.get("q") 
        if q:
            # return a filtered queryset
            return queryset.filter(title__icontains=q) 
        # No q is specified so we return queryset 
        return queryset
#+end_src

views:
#+begin_src python
# add to flavors/views.py
from django.views.generic import ListView
from core.views import TitleSearchMixin 
from .models import Flavor

class FlavorListView(TitleSearchMixin, ListView): 
    model = Flavor
#+end_src
#+begin_src python
# add to store/views.py
from django.views.generic import ListView
from core.views import TitleSearchMixin 
from .models import Store

class IceCreamStoreListView(TitleSearchMixin, ListView):
    model = Store
#+end_src

template:
{% raw %}
#+begin_src html
{# form to go into stores/store_list.html template #} 
<form action="" method="GET">
  <input type="text" name="q" /> 
  <button type="submit">search</button>
</form>
#+end_src
#+begin_src html
{# form to go into flavors/flavor_list.html template #} 
<form action="" method="GET">
  <button type="submit">search</button>
  <input type="text" name="q" /> 
</form>
#+end_src
{% endraw %}
* Templates
** Keep Templates Mostly in templates/
Template layout:
#+begin_src sh
templates/
    base.html
    ... (other sitewide templates in here)
    freezers/
        ("freezers" app templates in here)
#+end_src

However, some tutorials advocate putting templates within a subdirectory of each app. We find that the extra nesting is a pain to deal with
#+begin_src sh
 freezers/
     templates/
         freezers/
             ... ("freezers" app templates in here)
 templates/
     base.html
     ... (other sitewide templates in here)
#+end_src
** Template Architecture Patterns
*** 2-Tier Template Architecture Example
all templates inherit from a single root base.html
#+begin_src sh
templates/
    base.html
    dashboard.html # extends base.html
    profiles/
        profile_detail.html # extends base.html
        profile_form.html # extends base.html
#+end_src
This is best for sites with a consistent overall layout from app to app.
*** 3-Tier Template Architecture Example
+ Each app has a base_<app name>.html template. App-level base templates share a common parent base.html template.
+ Templates within apps share a common parent base_<app name>.html template.
+ Any template at the same level as base.html inherits base.html.
#+begin_src sh
templates/
    base.html
    dashboard.html # extends base.html
    profiles/
        base_profiles.html # extends base.html
        profile_detail.html # extends base_profiles.html
        profile_form.html # extends base_profiles.html
#+end_src
The 3-tier architecture is best for websites where each section requires a distinctive layout. For example, a news site might have a local news section, a classified ads section, and an events section. Each of these sections requires its own custom layout.
*** Flat Is Better Than Nested
template層數越少越好維護
** Limit Processing in Templates
Whenever you iterate over a queryset in a template, ask yourself the following questions:
+ How large is the queryset? Looping over gigantic querysets in your templates is almost always a bad idea.
+ How large are the objects being retrieved? Are all the fields needed in this template? 
+ During each iteration of the loop, how much processing occurs?

Let’s now explore some examples of template code that can be rewritten more efficiently.
Model:
#+begin_src python
# vouchers/models.py
from django.core.urlresolvers import reverse 
from django.db import models
from .managers import VoucherManager

class Voucher(models.Model):
    """Vouchers for free pints of ice c.ream.""" 
    name = models.CharField(max_length=100) 
    email = models.EmailField()
    address = models.TextField()
    birth_date = models.DateField(blank=True) 
    sent = models.BooleanField(default=False) 
    redeemed = models.BooleanField(default=False)
    objects = VoucherManager()
#+end_src
*** Gotcha 1: Aggregation in Templates
+ Don’t iterate over the entire voucher list in your template’s JavaScript section, using JavaScript variables to hold age range counts.
+ Don’t use the add template  lter to sum up the voucher counts.

*** Gotcha 2: Filtering With Conditionals in Templates
A very bad way to implement this would be with giant loops and if statements at the template level.
Bad Example:
{% raw %}
#+begin_src python
<h2>Greenfelds Who Want Ice Cream</h2> 
<ul>
{% for voucher in voucher_list %}
    {# Don't do this: conditional filtering in templates #}
    {% if "greenfeld" in voucher.name.lower %}
        <li>{{ voucher.name }}</li> 
    {% endif %}
{% endfor %} 
</ul>

<h2>Roys Who Want Ice Cream</h2> 
<ul>
{% for voucher in voucher_list %}
    {# Don't do this: conditional filtering in templates #}
    {% if "roy" in voucher.name.lower %}
        <li>{{ voucher.name }}</li> 
    {% endif %}
{% endfor %} 
</ul>
#+end_src
{% endraw %}

Good Example
views:
#+begin_src python

# vouchers/views.py
from django.views.generic import TemplateView
from .models import Voucher

class GreenfeldRoyView(TemplateView):
    template_name = "vouchers/views_conditional.html"
    def get_context_data(self, **kwargs):
        context = super(GreenfeldRoyView, self).get_context_data(**kwargs) 
        context["greenfelds"] = Voucher.objects.filter(name__icontains="greenfeld") 
        context["roys"] = Voucher.objects.filter(name__icontains="roy") 
        return context
#+end_src
template:
{% raw %}
#+begin_src python
<h2>Greenfelds Who Want Ice Cream</h2> 
<ul>
{% for voucher in greenfelds %}
    <li>{{ voucher.name }}</li> 
{% endfor %}
</ul>

<h2>Roys Who Want Ice Cream</h2> 
<ul>
{% for voucher in roys %}
    <li>{{ voucher.name }}</li> 
{% endfor %}
</ul>
#+end_src
{% endraw %}

*** Gotcha 3: Complex Implied Queries in Templates
Bad Example:
{% raw %}
#+begin_src python
{# list generated via User.object.all() #}
<h1>Ice Cream Fans and their favorite flavors.</h1> 
<ul>
{% for user in user_list %}
    <li>
        {{ user.name }}:
        {# DON'T DO THIS: Generated implicit query per user #}
        {{ user.flavor.title }}
        {# DON'T DO THIS: Second implicit query per user!!! #}
        {{ user.flavor.scoops_remaining }}
    </li> 
{% endfor %}
</ul>
#+end_src
{% endraw %}

One quick correction is to use the Django ORM’s *select related()* method:
{% raw %}
#+begin_src python
{% comment %}
List generated via User.object.all().select_related("flavors") 
{% endcomment %}
<h1>Ice Cream Fans and their favorite flavors.</h1>
<ul>
{% for user in user_list %}
    <li>
        {{ user.name }}:
        {{ user.flavor.title }}
        {{ user.flavor.scoops_remaining }} 
    </li>
{% endfor %} 
</ul>
#+end_src
{% endraw %}
*** Gotcha 4: Hidden CPU Load in Templates
需要大量CPU LOAD的code不該在template中，例如save image to file system
*** Gotcha 5: Hidden REST API Calls in Templates
REST API call不該放在template中，由於REST API可能會跑很久
建議在javascript code or view 中處理REST API call
 + JavaScript code so after your project serves out its content, the client’s browser handles the work.  is way you can entertain or distract the client while they wait for data to load.
 + The view’s Python code where slow processes might be handled in a variety of ways including message queues, additional threads, multiprocesses, or more.

** Exploring Template Inheritance
base.html:
{% raw %}
#+begin_src html
{# simple base.html #} 
{% load staticfiles %} 
<html>
<head>
    <title>
        {% block title %}Two Scoops of Django{% endblock title %}
    </title>
    {% block stylesheets %}
        <link rel="stylesheet" type="text/css" href="{% static "css/project.css" %}">
    {% endblock stylesheets %} </head>
<body>
    <div class="content">
        {% block content %} 
            <h1>Two Scoops</h1>
        {% endblock content %} 
    </div>
</body> 
</html>
#+end_src
{% endraw %}
The base.html file contains the following features:
+ A title block containing “Two Scoops of Django”.
+ A stylesheets block containing a link to a project.css file used across our site.
+ A content block containing “<h1>Two Scoops</h1>”.
{% raw %}
| Template Tag | Purpose                                                                                                                                                                            |
|--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| {% load %}   | Loads the staticfiles built-in template tag library                                                                                                                                |
| {% block %}  | Since base.html is a parent template, these define which child blocks can be filled in by child templates. We place links and scripts inside them so we can override if necessary. |
| {% static %} | Resolves the named static media argument to the static media server.                                                                                                               |
{% endraw %}

we’ll have a simple about.html inherit the following from it:
+ A custom title.
+ The original stylesheet and an additional stylesheet.
+ The original header, a sub header, and paragraph content.
+ The use of child blocks.
+ The use of the {{ block.super }} template variable.

{% raw %}
#+begin_src html
{% extends "base.html" %}
{% load staticfiles %}
{% block title %}About Audrey and Daniel{% endblock title %}
{% block stylesheets %}
    {{ block.super }}
    <link rel="stylesheet" type="text/css" href="{% static "css/about.css" %}">
{% endblock stylesheets %}
{% block content %}
    {{ block.super }}
    <h2>About Audrey and Daniel</h2> 
    <p>They enjoy eating ice cream</p>
{% endblock content %}
#+end_src
it generates the following HTML:
#+begin_src html
<html> 
<head>
    <title>
        About Audrey and Daniel
    </title>
    <link rel="stylesheet" type="text/css" href="/static/css/project.css"> 
    <link rel="stylesheet" type="text/css" href="/static/css/about.css">
</head> 
<body>
    <div class="content"> 
        <h1>Two Scoops</h1>
        <h2>About Audrey and Daniel</h2>
        <p>They enjoy eating ice cream</p> 
    </div>
</body> 
</html>
#+end_src

| Template Object   | Purpose                                                                                                                                                                                             |
|-------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| {% extends %}     | Informs Django that about.html is inheriting or extending from base.html                                                                                                                            |
| {% block %}       | Since about.html is a child template, block overrides the content provided by base.html. This means our title will render as <title>Audrey and Daniel</title>                                       |
| {{ block.super }} | When placed in a child template's block, it ensures that the parent's content is also included in the block. In the content block of the about.html template, this will render <h1>Two Scoops</h1>. |
{% endraw %}
** block.super Gives the Power of Control
Here are three examples:
{% raw %}
Template using both project.css and a custom link:
#+begin_src html
{% extends "base.html" %}
{% block stylesheets %}
    {{ block.super }} {# this brings in project.css #}
    <link rel="stylesheet" type="text/css" href="{% static "css/custom.css" %}" /> 
{% endblock %}
#+end_src

Dashboard template that excludes the project.css link:
#+begin_src html
{% extends "base.html" %}
{% block stylesheets %} .
    <link rel="stylesheet" type="text/css" href="{% static "css/dashboard.css" %}" />
    {% comment %}
        By not using {{ block.super }}, this block overrides the stylesheet block of base.html .
    {% endcomment %}
{% endblock %}
#+end_src

Template just linking the project.css file:
#+begin_src html
{% extends "base.html" %}
{% comment %}
    By not using {% block stylesheets %}, this template inherits the
    stylesheets block from the base.html parent, in this case the
    default project.css link.
{% endcomment %}
#+end_src
{% endraw %}
** Useful Things to Consider
*** Avoid Coupling Styles Too Tightly to Python Code
Aim to control the styling of all rendered templates entirely via CSS and JS.
+ If you have magic constants in your Python code that are entirely related to visual design layout, you should probably move them to a CSS file.
+ The same applies to JavaScript.
*** Common Conventions
{% raw %}
+ We prefer underscores over dashes in template names, block names, and other names in tem- plates. Most Django users seem to follow this convention. Why? Well, because underscores are allowed in names of Python objects but dashes are forbidden.
+ We rely on clear, intuitive names for blocks. {% block javascript %} is good.
+ We include the name of the block tag in the endblock. Never write just {% endblock %}, include the whole {% endblock javascript %}.
+ Templates called by other templates are prefixed with ‘_’.  is applies to templates called via {% include %} or custom template tags. It does not apply to templates inheritance controls such as {% extends %} or {% block %}.
{% endraw %}
*** Location
Templates should usually go into the root of the Django project, at the same level as the apps.
The only exception is when you bundle up an app into a third-party package. That packages template directory should go into app directly.
*** Use Named Context Objects
{% raw %}
use {{ topping list }} and {{ topping }} in your templates, instead of {{ object list }} and {{ object }}
{% endraw %}
*** Use URL Names Instead of Hardcoded Paths
A common developer mistake is to hardcode URLs in templates like this:
{% raw %}
#+begin_src python
<a href="/flavors/">
#+end_src
Instead, we use the {% url %} tag and references the names in our URLConf  les:
#+begin_src python
<a href="{% url 'flavors_list' %}">
#+end_src
{% endraw %}
*** Debugging Complex Templates
A trick recommended by Lennart Regebro is that when templates are complex and it becomes dif-  cult to determine where a variable is failing, you can force more verbose errors through the use of the string if invalid option in OPTIONS of your TEMPLATES setting:
#+begin_src python
# settings/local.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'APP_DIRS': True,
        'OPTIONS':
            'string_if_invalid': 'INVALID EXPRESSION: %s'
    }, 
]
#+end_src
** Error Page Templates
It’s standard practice to create at least 404.html and 500.html templates.
We suggest serving your error pages from a static file server (e.g. Nginx or Apache) as entirely self- contained static HTML files. That way, if your entire Django site goes down but your static  le server is still up, then your error pages can still be served.

GitHub’s 404 and 500 error pages are great examples of fancy but entirely static, self-contained error pages:
+ https://github.com/404
+ https://github.com/500
+ All CSS styles are inline in the head of the same HTML page, eliminating the need for a separate stylesheet.
+ All images are entirely contained as data within the HTML page.  ere are no <img> links to external URLs.
+ All JavaScript needed for the page is contained within the HTML page. There are no external links to JavaScript assets.

For more information, see the Github HTML Styleguide:
+ https://github.com/styleguide

* Template Tags and Filters
** Filters Are Functions
Filters are functions that accept just one or two arguments.
大多數的filters都只是作很簡單的事，通常都是將實作寫在utils.py，再由filters去import utils.py
可參考django的default filters實作：https://github.com/django/django/blob/stable/1.8.x/django/template/defaultfilters.py
django.template.defaultfilters.slugify是呼叫django.utils.text.slugify
*** When to Write Filters
*Filters are good for modifying the presentation of data*, and they can be readily reused in REST APIs and other output formats.
** Custom Template Tags
+ Template Tags Are Harder to Debug
+ Template Tags Make Code Reuse Harder
+ The Performance Cost of Template Tags
*** When to Write Template Tags
Think these before writing custom tags:
+ Anything that causes a read/write of data might be better placed in a model or object method.
+ Since we implement a consistent naming standard across our projects, we can add an abstract base class model to our core.models module. Can a method or property in our project’s abstract base class model do the same work as a custom template tag?

When should you write new template tags? We recommend writing them in situations where they are only responsible for rendering of HTML. For example, projects with very complex HTML layouts with many different models or data types might use them to create a more  exible, understandable template architecture.

** Naming Your Template Tag Libraries
The convention we follow is <app name>_tags.py.
+ flavors_tags.py 
+ blog_tags.py

** Loading Your Template Tag Modules
{% raw %}
#+begin_src python
{% extends "base.html" %}

{% load flavors_tags %}
#+end_src
{% endraw %}
*** Watch Out for This Crazy Anti-Pattern
*Don't Use This*
#+begin_src python
# Don't use this code!
# It's an evil anti-pattern! 
from django import template 
template.add_to_builtins(
    "flavors.templatetags.flavors_tags"
)
#+end_src
* Building REST APIs
** Fundamentals of Basic REST API Design
HTTP method:
| Purpose of Request                                  | HTTP Method | Rough SQL equivalent |
|-----------------------------------------------------+-------------+----------------------|
| Create a new resource                               | POST        | INSERT               |
| Read an existing resource                           | GET         | SELECT               |
| Request the metadata of an existing resource        | HEAD        |                      |
| Update an existing resource                         | PUT         | UPDATE               |
| Update part of an existing resource                 | PATCH       | UPDATE               |
| Delete an existing resource                         | DELETE      | DELETE               |
| Return the supported HTTP methods for the given URL | OPTIONS     |                      |
| Echo back the request                               | TRACE       |                      |
| Tunneling over TCP/IP (usually not implemented)     | CONNECT     |                      |

some common HTTP status codes:
[[{% asset_img table16_2.png %}]]

** Implementing a Simple JSON API
*use django-rest-framework*
model:
#+begin_src python
# flavors/models.py
from django.core.urlresolvers import reverse 
from django.db import models

class Flavor(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField(unique=True) 
    scoops_remaining = models.IntegerField(default=0)

    def get_absolute_url(self):
        return reverse("flavors:detail", kwargs={"slug": self.slug})
#+end_src
Define the serializer class:
#+begin_src python

from rest_framework import serializers
from .models import flavor

class FlavorSerializer(serializers.ModelSerializer):
    class Meta:
        model = flavor
        fields = ('title', 'slug', 'scoops_remaining')
#+end_src
Views:
#+begin_src python
# flavors/views
from rest_framework.generics import ListCreateAPIView
from rest_framework.generics import RetrieveUpdateDestroyAPIView 
from .models import Flavor
from .serializers import FlavorSerializer

class FlavorCreateReadView(ListCreateAPIView):
    queryset = Flavor.objects.all()
    serializer_class = FlavorSerializer
    lookup_field = 'slug'

class FlavorReadUpdateDeleteView(RetrieveUpdateDestroyAPIView): 
    queryset = Flavor.objects.all()
    serializer_class = FlavorSerializer
    lookup_field = 'slug'
#+end_src
flavors/urls.py:
#+begin_src python

# flavors/urls.py
from django.conf.urls import url
from flavors import views

urlpatterns = [
    url(
        regex=r"ˆapi/$", 
        view=views.FlavorCreateReadView.as_view(), 
        name="flavor_rest_api"
    ), 
    url(
        regex=r"ˆapi/(?P<slug>[-\w]+)/$",
        view=views.FlavorReadUpdateDeleteView.as_view(),
        name="flavor_rest_api"
    )
]
#+end_src
| Url                 | View                       | Url Name (same) |
|---------------------+----------------------------+-----------------|
| /flavors/api/       | FlavorCreateReadView       | flavor_rest api |
| /flavors/api/:slug/ | FlavorReadUpdateDeleteView | flavor_rest api |

Don't forget to add authenticate and permissions:
+ http://www.django-rest-framework.org/api-guide/authentication/
+ http://www.django-rest-framework.org/api-guide/permissions/
** REST API Architecture
*** Code for a Project Should Be Neatly Organized
For example, we might place all our views, serializers, and other API components in an app titled apiv4.
The downside is the possibility for the API app to become too large and disconnected from the apps that power it. Hence why we consider an alternative in the next subsection.
*** Code for an App Should Remain in the App
REST APIs are just views. For simpler, smaller projects, REST API views should go into views.py or viewsets.py modules
The downside is that if there are too many small, interconnecting apps, it can be hard to keep track of the myriad of places API components are placed. Hence why we considered another approach in the previous subsection.

*** Grouping API URLs
If you have REST API views in multiple Django apps, how do you build a project-wide API that looks like this?
#+begin_src sh
api/flavors/ # GET, POST 
api/flavors/:slug/ # GET, PUT, DELETE
api/users/ # GET, POST
api/users/:slug/ # GET, PUT, DELETE
#+end_src
{% raw %}
#+begin_src python
 # core/api.py
"""Called from the project root's urls.py URLConf thus:
        url(r"ˆapi/", include("core.api", namespace="api")), 
"""
from django.conf.urls import url
from flavors import views as flavor_views 
from users import views as user_views

 urlpatterns = [
     # {% url "api:flavors" %}
     url(
        regex=r"ˆflavors/$", 
        view=flavor_views.FlavorCreateReadView.as_view(), 
        name="flavors" .
     ),

     # {% url "api:flavors" flavor.slug %}
     url(
        regex=r"ˆflavors/(?P<slug>[-\w]+)/$", 
        view=flavor_views.FlavorReadUpdateDeleteView.as_view(), 
        name="flavors"
     ),

     # {% url "api:users" %}
     url(
        regex=r"ˆusers/$", 
        view=user_views.UserCreateReadView.as_view(), 
        name="users"
     ),

     # {% url "api:users" user.slug %}
     url(
          regex=r"ˆusers/(?P<slug>[-\w]+)/$", 
          view=user_views.UserReadUpdateDeleteView.as_view(), 
          name="users" .
    ),
]
#+end_src
{% endraw %}
*** Version Your API
It’s a good practice to abbreviate the urls of your API with the version number e.g. /api/v1/flavors or /api/v1/users and then as the API changes, /api/v2/flavors or /api/v2/users.
** Shutting Down an External API
1. Notify User
2. Replace API With 410 Error View
#+begin_src python
# core/apiv1_shutdown.py
from django.http import HttpResponseGone

apiv1_gone_msg = """APIv1 was removed on April 2, 2015. Please switch to APIv3:
<ul>
    <li>
        <a href="https://www.example.com/api/v3/">APIv3 Endpoint</a>
    </li> 
    <li>
        <a href="https://example.com/apiv3_docs/">APIv3 Documentation</a>
    </li> 
    <li>
        <a href="http://example.com/apiv1_shutdown/">APIv1 shut down notice</a>
    </li>
</ul> 
"""
def apiv1_gone(request):
    return HttpResponseGone(apiv1_gone_msg)
#+end_src
** Rate Limiting Your API
Rate limiting is when an API restricts how many requests can be made by a user of the API within a period of time.
* Working With the Django Admin
** It's Not for End Users
The Django admin interface is designed for site administrators, not end users.
** Add __str__ to Model
The default admin page for a Django app looks something like this:
[[{% asset_img figure19_2.png %}]]

Implementing __str__():
#+begin_src python
from django.db import models
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible # For Python 3.4 and 2.7 
class IceCreamBar(models.Model):
    name = models.CharField(max_length=100)
    shell = models.CharField(max_length=100)
    filling = models.CharField(max_length=100)
    has_stick = models.BooleanField(default=True)

    def __str__(self): 
        return self.name
#+end_src
The result:
[[{% asset_img figure19_3.png %}]]

If you still want to show data for additional  elds on the app’s admin list page, you can then use list display:
#+begin_src python
from django.contrib import admin
from .models import IceCreamBar

class IceCreamBarAdmin(admin.ModelAdmin):
    list_display = ("name", "shell", "filling",)

admin.site.register(IceCreamBar, IceCreamBarAdmin)
#+end_src
The result with the specified fields:
[[{% asset_img figure19_5.png %}]]
** Adding Callables to ModelAdmin Classes
For example, it’s not uncommon to want to see the exact URL of a model instance in the Django admin.
#+begin_src python
from django.contrib import admin
from django.core.urlresolvers import reverse 
from django.utils.html import format_html
from icecreambars.models import IceCreamBar 

class IceCreamBarAdmin(admin.ModelAdmin):
    list_display = ("name", "shell", "filling",)
    readonly_fields = ("show_url",)

    def show_url(self, instance):
        url = reverse("ice_cream_bar_detail",
                kwargs={"pk": instance.pk})
        response = format_html("""<a href="{0}">{1}</a>""", url, url) 
        return response

    show_url.short_description = "Ice Cream Bar URL"
    # Displays HTML tags
    # Never set allow_tags to True against user submitted data!!!
    show_url.allow_tags = True

admin.site.register(IceCreamBar, IceCreamBarAdmin)
#+end_src
[[{% asset_img figure19_6.png %}]]
** Django's Admin Documentation Generator
1. pip install docutils into your project’s virtualenv. 
2. Add django.contrib.admindocs to your INSTALLED APPS. 
3. Add (r'ˆadmin/doc/', include('django.contrib.admindocs.urls')) to your root URLConf. Make sure it’s included before the r'ˆadmin/' entry, so that requests to /admin/doc/ don’t get handled by the latter entry.
4. Optional : Linking to templates requires the ADMIN FOR setting to be con gured.
5. Optional : Using the admindocs bookmarklets requires the XViewMiddleware to be installed.
 
** Securing the Django Admin and Django Admin Docs
* Dealing With the User Model
** Use Django's Tools for Finding the User Model
The advised way to get to the user class is as follows:
#+begin_src python
# Stock user model definition
>>> from django.contrib.auth import get_user_model
>>> get_user_model()
<class 'django.contrib.auth.models.User'> .

# When the project has a custom user model definition 
>>> from django.contrib.auth import get_user_model 
>>> get_user_model()
<class 'profiles.models.UserProfile'>
#+end_src
*** Use settings.AUTH_USER_MODEL for Foreign Keys to User
#+begin_src python
from django.conf import settings 
from django.db import models

class IceCreamStore(models.Model):
    owner = models.OneToOneField(settings.AUTH_USER_MODEL)
    title = models.CharField(max_length=255)
#+end_src
*** Don't Use get user model() for Foreign Keys to User
This is bad, as it tends to create import loops.
#+begin_src python
# DON'T DO THIS!
from django.db import models
from django.contrib.auth import get_user_model

class IceCreamStore(models.Model):
    # This following line tends to create import loops.
    owner = models.OneToOneField(get_user_model())
    title = models.CharField(max_length=255)
#+end_src
** Custom User Fields for Django 1.8 Projects
*** Option 1: Subclass AbstractUser
Choose this option if you like Django’s User model  elds the way they are, but need extra fields.
#+begin_src python
# profiles/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils.translation import ugettext_lazy as _

class KarmaUser(AbstractUser):
    karma = models.PositiveIntegerField(verbose_name=_("karma"), default=0, blank=True)
#+end_src
The other thing you have to do is set this in your settings:
#+begin_src python
AUTH_USER_MODEL = "profiles.KarmaUser" .
#+end_src
*** Option 2: Subclass AbstractBaseUser
AbstractBaseUser is the bare-bones option with only 3 fields: password, last login, and is active.
Choose this option if:
+ You’re unhappy with the  elds that the User model provides by default, such as first name and last name.
+ You prefer to subclass from an extremely bare-bones clean slate but want to take advantage of the AbstractBaseUser sane default approach to storing passwords.

If you want to go down this path, we recommend the following reading:
+ Official Django Documentation Example http://2scoops.co/1.8-custom-user-model-example
+ Source code of django-authtools (Especially admin.py,forms.py,andmodels.py) https://github.com/fusionbox/django-authtools
*** Option 3: Linking Back From a Related Model
/Use Case: Creating a Third Party Package/
+ We are creating a third-party package for publication on PyPI.
+ The package needs to store additional information per user, perhaps a Stripe ID or another payment gateway identifier.
+ We want to be as unobtrusive to the existing project code as possible. Loose coupling!

/Use Case: Internal Project Needs/
+ We are working on our own Django project.
+ We want different types of users to have different fields.
+ We might have some users with a combination of different user types.
+ We want to handle this at the model level, instead of at other levels.
+ We want this to be used in conjunction with a custom user model from options #1 or #2.

#+begin_src python
# profiles/models.py
from django.conf import settings
from django.db import models
from flavors.models import Flavor 

class EaterProfile(models.Model):
    # Default user profile
    # If you do this you need to either have a post_save signal or
    #     redirect to a profile_edit view on initial login.
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    favorite_ice_cream = models.ForeignKey(Flavor, null=True, blank=True)

class ScooperProfile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    scoops_scooped = models.IntegerField(default=0) 

class InventorProfile(models.Model):
    user = models.OneToOneField(setting.s.AUTH_USER_MODEL)
    flavors_invented = models.ManyToManyField(Flavor, null=True, blank=True)
#+end_src
* Third-Party Packages
PyPI (https://pypi.python.org/pypi)
Django Packages (https://www.djangopackages.com/)
** Wiring Up Django Packages: The Basics
+ Step 1: Read the Documentation for the Package
+ Step 2: Add Package and Version Number to Your Requirements
+ Step 3: Install the Requirements Into Your Virtualenv
+ Step 4: Follow the Package's Installation Instructions Exactl
* Testing
** Useful Library for Testing Django Projects
[[https://bitbucket.org/ned/coveragepy][coverage.py]]
** How to Structure Tests
/“Flat is better than nested,”/
#+begin_src sh
popsicles/
    __init__.py
    admin.py
    forms.py
    models.py
    test_forms.py
    test_models.py
    test_views.py
    views.py
#+end_src
** How to Write Unit Tests
*** Each Test Method Tests One Thing
example:
#+begin_src python
# flavors/test_api.py 
import json
from django.core.urlresolvers import reverse 
from django.test import TestCase
from flavors.models import Flavor

class DjangoRestFrameworkTests(TestCase):
    def setUp(self):
        Flavor.objects.get_or_create(title="title1", slug="slug1") 
        Flavor.objects.get_or_create(title="title2", slug="slug2")
        self.create_read_url = reverse("flavor_rest_api")
        self.read_update_delete_url = reverse("flavor_rest_api", kwargs={"slug": "slug1"})

    def test_list(self):
        response = self.client.get(self.create_read_url)
        # Are both titles in the conten.t? 
        self.assertContains(response, "title1") 
        self.assertContains(response, "title2")

    def test_detail(self):
        response = self.client.get(self.read_update_delete_url) 
        data = json.loads(response.content)
        content = {"id": 1, "title": "title1", "slug": "slug1", "scoops_remaining": 0}
        self.assertEquals(data, content)

    def test_create(self):
        post = {"title": "title3", "slug": "slug3"}
        response = self.client.post(self.create_read_url, post) 
        data = json.loads(response.content) 
        self.assertEquals(response.status_code, 201)
        content = {"id": 3, "title": "title3", "slug": "slug3", "scoops_remaining": 0}
        self.assertEquals(data, content)
        self.assertEquals(Flavor.objects.count(), 3)

    def test_delete(self):
        response = self.client.delete(self.read_update_delete_url) 
        self.assertEquals(response.status_code, 204) 
        self.assertEquals(Flavor.objects.count(), 1)
#+end_src
* Reference
此筆記大多來自這本書：
Two Scoops of Django: Best Practices for Django 1.8
by Daniel Roy Greenfeld (Author), Audrey Roy Greenfeld (Author)
https://www.twoscoopspress.com/
