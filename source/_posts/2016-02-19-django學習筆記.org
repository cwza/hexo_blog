#+TITLE: django學習筆記
#+DATE: <2016-02-19 Fri 16:15>   
#+TAGS: python, django
#+LAYOUT: post
#+CATEGORIES: python
#+OPTIONS: toc:t \n:t

django學習筆記
隨筆亂記，陸續增加中
#+BEGIN_HTML
<!--more-->
#+END_HTML

* Layout Django Project
直接參考github上大大寫好的layout工具吧
https://github.com/pydanny/cookiecutter-django

* Setting Files
** 如何處理多環境設定(production, staging, local)
將setting files分開成各個環境，所有setting file全部進入git控管
底下為例子，在<repository root>/config/settings
#+begin_src sh
settings/
      __init__.py
      base.py
      dev_audreyr.py
      dev_pydanny.py
      local.py
      staging.py
      test.py
      production.py
#+end_src

local設定繼承自base
#+begin_src python
# settings/local.py 
from .base import *
DEBUG = True

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": "twoscoops",
        "USER": "",
        "PASSWORD": "",
        "HOST": 
        "localhost",
        "PORT": "",
        } 
}

INSTALLED_APPS += ("debug_toolbar", )
#+end_src

個人設定，繼承自local
#+begin_src python
# settings/dev_pydanny.py 
from .local import *
# Set short cache timeout
CACHE_TIMEOUT = 30
#+end_src

執行時用以下方式指定setting file執行
#+begin_src sh
django-admin shell --settings=twoscoops.settings.local
django-admin runserver --settings=twoscoops.settings.local
#+end_src
在server上可以設定環境變數DJANGO SETTINGS MODULE and PYTHONPATH來指定setting file，或利用virtualenv來設定(add Export to the end of virtualenv's bin/activate)
** 重要的secret key問題(secret key不該進入version control)
secret key不該進入version control所以不要把它放在setting file中
最好是放在environment variable，setting file中用os.environ["SOME_SECRET_KEY"]去拿

linux下將以下放到.bashrc, .bash_profile, or .profile
或利用virtualenv來設定(add Export to the end of virtualenv's bin/activate)
#+begin_src sh
export SOME_SECRET_KEY=1c3-cr3am-15-yummy
#+end_src

setting file用以下方式拿secret key
#+begin_src python
# Top of settings/production.py
import os
SOME_SECRET_KEY = os.environ["SOME_SECRET_KEY"]
#+end_src

上述方式在拿不到environ variable時錯誤訊息會是key_error，不甚好，可在base.py中加入以下改良
#+begin_src python
# settings/base.py 
import os
# Normally you should not import ANYTHING from Django directly
# into your settings, but ImproperlyConfigured is an exception.
from django.core.exceptions import ImproperlyConfigured .
def get_env_variable(var_name):
    """Get the environment variable or return exception.""" 
    try:
        return os.environ[var_name] 
    except KeyError:
        error_msg = "Set the {} environment variable".format(var_name)
        raise ImproperlyConfigured(erro.r_msg)
#+end_src

#+begin_src python
SOME_SECRET_KEY = get_env_variable("SOME_SECRET_KEY")
#+end_src
** 當環境限制無法使用environment variable時怎麼做呢
將secret_key放進json file(or xml, yml ...etc)，setting file中利用json util將secret_key讀出，注意此secret file不該進入version control
#+begin_src javascript
{
    "FILENAME": "secrets.json",
    "SECRET_KEY": "I've got a secret!",
    "DATABASES_HOST": "127.0.0.1",
    "PORT": "5432"
}
#+end_src

#+begin_src python
# settings/base.py
import json
# Normally you should not import ANYTHING from Django directly # into your settings, but ImproperlyConfigured is an exception. from django.core.exceptions import ImproperlyConfigured

# JSON-based secrets module

with open("secrets.json") as f:
    secrets = json.loads(f.read())
def get_secret(setting, secrets=secrets):
    """Get the secret variable or return explicit exception."""
    try:
        return secrets[setting] 
    except KeyError:
        error_msg = "Set the {0} environment variable".format(setting) 
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_secret("SECRET_KEY")
#+end_src

** Requirements Files也要照環境分開
不同環境可能需要裝不同package(ex: local才需要debug工具)
在<repository root>/requirements
#+begin_src sh
requirements/
    base.txt
    local.txt
    staging.txt
    production.txt
#+end_src

in base.txt
#+begin_src python
Django==1.8.0
psycopg2==2.6
djangorestframework==3.1.1
#+end_src

in local.txt
#+begin_src python
-r base.txt # includes the base.txt requirements file

coverage==3.7.1
django-debug-toolbar==1.3.0
#+end_src

in production.txt
#+begin_src python
-r base.txt # includes the base.txt requirements file
#+end_src

裝package時用以下指令指定requirements檔案安裝
#+begin_src sh
$ pip install -r requirements/local.txt
$ pip install -r requirements/production.txt
#+end_src
** Setting Files中的Path不要使用Absolute Path
利用Unipath (http://pypi.python.org/pypi/Unipath/)
#+begin_src python
# At the top of settings/base.py 
from unipath import Path

BASE_DIR = Path(__file__).ancestor(3)
MEDIA_ROOT = BASE_DIR.child("media")
STATIC_ROOT = BASE_DIR.child("static")
STATICFILES_DIRS = (
    BASE_DIR.child("assets"),
)
TEMPLATES = [
    {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         DIRS = (BASE_DIR.child("templates"),)
     },
]
#+end_src

或用python內建的os.path
#+begin_src python
# At the top of settings/base.py
from os.path import join, abspath, dirname
here = lambda *dirs: join(abspath(dirname(__file__)), *dirs) BASE_DIR = here("..", "..")
root = lambda *dirs: join(abspath(BASE_DIR), *dirs)

# Configuring MEDIA_ROOT
MEDIA_ROOT = root("media")

# Configuring STATIC_ROOT
STATIC_ROOT = root("collected_static")

# Additional locations of static files
STATICFILES_DIRS = (
    root("assets"),
)

# Configuring TEMPLATE_DIRS
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        DIRS = (root("templates"),)
    }, 
]
#+end_src
* Model
** Model Inheritance
當重複field太多時，可考慮abstract base inheritance，例如幾乎每個model都要有created, modified
+ Abstract base classes: 實際上DB不會有parent table
+ multi-table inheritance: DB確實會長出parent table and child table然後用foreign key連結
+ proxy models

*不要使用multi-table inheritance，由於其實是使用foreign key處理所以會有效能問題*

以下為例子
core.models.TimeStampedModel裡有常用的created and modified field
flavors.Flovor繼承TimeStampedModel的field
注意
    class Meta: 
        abstract = True
#+begin_src python
# core/models.py
from django.db import models
class TimeStampedModel(models.Model): 
    """
    An abstract base class model that provides self-
    updating ``created`` and ``modified`` fields.
    """
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)

    class Meta: 
        abstract = True
#+end_src
#+begin_src python
# flavors/models.py
from django.db import models
from core.models import TimeStampedModel

class Flavor(TimeStampedModel):
    title = models.CharField(max_length=200)
#+end_src
** Model Design Ordering
1. Start Normalized
2. Cache Before Denormalizing
3. Denormalize Only if Absolutely Needed(try cache, row SQL, indexes)
** When to Use Null and Blank
[[{% asset_img table6_2.png %}]]
** When to Use BinaryField
*Don't Serve Files From BinaryField. Use FileField!!!*
+ MessagePack-formatted content.
+ Raw sensor data.
+ Compressed data e.g. the type of data Sentry stores as a BLOB, but is required to base64-encode due to legacy issues.
** Try to Avoid Using Generic Relations
Cons:
+ Reduction in speed of queries due to lack of indexing between models.
+ Danger of data corruption as a table can refer to another against a non-existent record.
So:
+ Try to avoid generic relations and GenericForeignKey.
+ If you think you need generic relations, see if the problem can be solved through better model design or the new PostgreSQL  elds.
+ If usage can’t be avoided, try to use an existing third-party app.  e isolation a third-party app provides will help keep data cleaner.
** The Model meta API
Main Usages:
+ Get a list of a model’s fields.
+ Get the class of a particular  eld for a model (or its inheritance chain or other info derived from such).
+ Ensure that how you get this information remains constant across future Django versions.

Examples:
+ Building a Django model introspection tool.
+ Building your own custom specialized Django form library.
+ Creating admin-like tools to edit or interact with Django model data.
+ Writing visualization or analysis libraries, e.g. analyzing info only about  elds that start with “foo”.
** Fat Models
將跟DB有關的邏輯從view中抽出放到Model中包裝是好的設計，但project到最後會發生Model肥大的問題，一個Model數千行這就不好了，底下提供兩個解法
+ Model Behaviors Pattern: http://blog.kevinastone.com/django-model-behaviors.html
+ Mixin
* Queries and the Database Layer
** Use get object or 404() for Single Objects instead of get()
+ Only use it in views.
+ Don’t use it in helper functions, forms, model methods or anything that is not a view or directly view related.
** Be Careful With Queries That Might Throw Exceptions
*** ObjectDoesNotExist vs. DoesNotExist
ObjectDoesNotExist can be applied to any model object, whereas DoesNotExist is for a speci c model.
#+begin_src python
from django.core.exceptions import ObjectDoesNotExist 
from flavors.models import Flavor
from store.exceptions import OutOfStock

def list_flavor_line_item(sku): 
    try:
        return Flavor.objects.get(sku=sku, quantity__gt=0)
    except Flavor.DoesNotExist:
        msg = "We are out of {0}".format(sku) 
        raise OutOfStock(msg)
def list_any_line_item(model, sku): 
    try:
        return model.objects.get(sku=sku, quantity__gt=0) 
    except ObjectDoesNotExist:
        msg = "We are out of {0}".format(sku) 
        raise OutOfStock(msg)
#+end_src
*** When You Just Want One Object but Get Three Back
check for a MultipleObjectsRe- turned exception
#+begin_src python
from flavors.models import Flavor
from store.exceptions import OutOfStock, CorruptedDatabase

def list_flavor_line_item(sku): 
    try:
        return Flavor.objects.get(sku=sku, quantity__gt=0) .
    except Flavor.DoesNotExist:
        msg = "We are out of {}".format(sku) 
        raise OutOfStock(msg)
    except Flavor.MultipleObjectsReturned:
        msg = "Multiple items have SKU {}. Please fix!".format(sku) 
        raise CorruptedDatabase(msg)
#+end_src
** Transactions
*** Wrapping Each HTTP Request in a Transaction
#+begin_src python
# settings/base.py
DATABASES = {
'default': {
        # ...
        'ATOMIC_REQUESTS': True,
        },
}
#+end_src

non atomic function include atomic code:
#+begin_src python
# flavors/views.py
from django.db import transaction
from django.http import HttpResponse
from django.shortcuts import get_object_or_404 
from django.utils import timezone
from .models import Flavor

@transaction.non_atomic_requests
def posting_flavor_status(request, pk, status):
    flavor = get_object_or_404(Flavor, pk=pk)

    # This will execute in autocommit mode (Django's default).
    flavor.latest_status_change_attempt = timezone.now()
    flavor.save()

    with transaction.atomic():
    # This code executes inside a transaction. 
        flavor.status = status 
        flavor.latest_status_
        change_success = timezone.now() 
        flavor.save()
        return HttpResponse("Hooray")

    # If the transaction fails, return the appropriate status 
    return HttpResponse("Sadness", status_code=400)

#+end_src
*** Explicit Transaction Declaration
* Function- and Class-Based Views
** When to Use FBVs or CBVs
[[{% asset_img figure8_1.png %}]]
** Keep View Logic Out of URLConfs
Bad Example:
#+begin_src python
from django.conf.urls import url
from django.views.generic import DetailView
from tastings.models import Tasting

urlpatterns = [ 
    url(r"ˆ(?P<pk>\d+)/$",
        DetailView.as_view(
            model=Tasting,
            template_name="tastings/detail.html"),
        name="detail"),
    url(r"ˆ(?P<pk>\d+)/results/$", 
        DetailView.as_view(
            model=Tasting,
            template_name="tastings/results.html"),
        name="results"),
]

#+end_src

Good view example:
#+begin_src python
# tastings/views.py
from django.views.generic import ListView, DetailView, UpdateView 
from django.core.urlresolvers import reverse
from .models import Tasting 

class TasteListView(ListView):
    model = Tasting
class TasteDetailView(DetailView):
    model = Tasting
class TasteResultsView(TasteDetailView):
    template_name = "tastings/results.html"
class TasteUpdateView(UpdateView): 
    model = Tasting
    def get_success_url(self):
        return reverse("tastings:detail",
            kwargs={"pk": self.object.pk})
#+end_src

Good urls example:
#+begin_src python
# tastings/urls.py
from django.conf.urls import url
from . import views

urlpatterns = [
    url(
        regex=r"ˆ$", 
        view=views.TasteListView.as_view(), 
        name="list"
    ),
    url(
        regex=r"ˆ(?P<pk>\d+)/$", 
        view=views.TasteDetailView.as_view(), 
        name="detail"
    ), 
    url(
        regex=r"ˆ(?P<pk>\d+)/results/$", 
        view=views.TasteResultsView.as_.view(), 
        name="results"
    ), 
    url(
        regex=r"ˆ(?P<pk>\d+)/update/$", 
        view=views.TasteUpdateView.as_view(), 
        name="update"
    ) 
]
#+end_src
** Use URL Namespaces
In the root URLConf we would add:
#+begin_src python
# urls.py at root of project
urlpatterns += [
    url(r'ˆtastings/', include('tastings.urls', namespace='tastings')),
]
#+end_src

view example:
#+begin_src python
# tastings/views.py snippet
class TasteUpdateView(UpdateView):
    model = Tasting
    def get_success_url(self):
        return reverse("tastings:detail", .
            kwargs={"pk": self.object.pk})
#+end_src

template example:
{% raw %}
#+begin_src python
{% extends "base.html" %}
{% block title %}Tastings{% endblock title %}
{% block content %}
<ul>
  {% for taste in tastings %} 
    <li>
      <a href="{% url "tastings:detail" taste.pk %}">{{ taste.title }}</a>
      <small>
        (<a href="{% url "tastings:update" taste.pk %}">update</a>)
      </small>
    </li>
  {% endfor %}
</ul>
{% endblock content %}
#+end_src
{% endraw %}
** Django Views Are Functions
Class-Based Views Are Actually Called as Functions
#+begin_src python
# simplest_views.py
from django.http import HttpResponse 
from django.views.generic import View

# The simplest FBV
def simplest_view(request):
    # Business logic goes here 
    return HttpResponse("FBV")

# The simplest CBV
class SimplestView(View):
    def get(self, request, *args, **kwargs):
       # Business logic goes here
       return HttpResponse("CBV")
#+end_src
** Don't Use locals() as Views Context
Bad example:
#+begin_src python
def ice_cream_store_display(request, store_id): 
    store = get_object_or_404(Store, id=store_id)
    now = timezone.now()
    return render(request, 'melted_ice_cream_report.html', locals())
#+end_src

Good example:
#+begin_src python
def ice_cream_store_display(request, store_id):
    return render(request, 'melted_ice_cream_report.html', dict{
        'store': get_object_or_404(Store, id=store_id),
        'now': timezone.now()
    })
#+end_src
* Function-Based Views
** Use Decorator To Modify Request And Response
Here’s a sample decorator template for use in function-based views:
functools.wraps() is a convenience tool that copies over metadata including critical data like docstrings to the newly decorated function.
#+begin_src python
# simple decorator template import functools
def decorator(view_func): 
    @functools.wraps(view_func)
    def new_view_func(request, *args, **kwargs):
        # You can modify the request (HttpRequest) object here. 
        response = view_func(request, *args, **kwargs)
        # You can modify the response (HttpResponse) object here. 
        return response
    return new_view_func
#+end_src

check_sprinkles is a decorator to modify request:
#+begin_src python
# sprinkles/decorators.py 
from functools import wraps
from . import utils

# based off the decorator template from Example 8.5 
def check_sprinkles(view_func):
"""Check if a user can add sprinkles""" 
    @wraps(view_func)
    def new_view_func(request, *args, **kwargs):
        # Act on the request object with utils.can_sprinkle()
        request = utils.can_sprinkle(request)
        # Call the view function
        response = view_func(request, *args, **kwargs)
        # Return the HttpResponse object
        return response 
    return new_view_func
#+end_src

Then we attach it to the function thus:
#+begin_src python
# views.py
from django.shortcuts import get_object_or_404, render
from .decorators import check_sprinkles
from .models import Sprinkle

# Attach the decorator to the view 
@check_sprinkles
def sprinkle_detail(request, pk):
    """Standard detail view"""
    sprinkle = get_object_or_404(Sprinkle, pk=pk)
    return render(request, "sprinkles/sprinkle_detail.html",
        {"sprinkle": sprinkle})
#+end_src
* Class-Based Views
** Guidelines When Working With CBVs
+ Less view code is better.
+ Never repeat code in views.
+ Views should handle presentation logic. Try to keep business logic in models when possible, or in forms if you must.
+ Keep your views simple.
+ Don’t use CBVs to write custom 403, 404, and 500 error handlers. Use FBVs instead.
+ Keep your mixins simpler.
** Using Mixins With CBVs
The rules follow Python’s method resolution order, which in the most simplistic de nition possible, proceeds from left to right:
1. The base view classes provided by Django always go to the right.
2. Mixins go to the left of the base view.
3. Mixins should inherit from Python’s built-in object type.

Example of the rules in action:
#+begin_src python
from django.views.generic import TemplateView 

class FreshFruitMixin(object):
    def get_context_data(self, **kwargs): 
        context = super(FreshFruitMixin,
            . self).get_context_data(**kwargs)
        context["has_fresh_fruit"] = True 
        return context

class FruityFlavorView(FreshFruitMixin, TemplateView): 
    template_name = "fruity_flavor.html"
#+end_src
** Which Django GCBV Should Be Used for What Task?
[[{% asset_img table10_1.png %}]]
** General Tips for Django CBVs
*** Constraining Django CBV/GCBV Access to Authenticated Users
Use django-braces LoginRequiredMixin
#+begin_src python
# flavors/views.py
from django.views.generic import DetailView
from braces.views import LoginRequiredMixin
from .models import Flavor

class FlavorDetailView(LoginRequiredMixin, DetailView):
    model = Flavor
#+end_src
*** Performing Custom Actions on Views With Valid Forms
#+begin_src python
from django.views.generic import CreateView 
from braces.views import LoginRequiredMixin 
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    def form_valid(self, form):
        # Do custom logic here
        return super(FlavorCreateView, self).form_valid(form)
#+end_src
To perform custom logic on form data that has already been validated, simply add the logic to formvalid().  e return value of formvalid() should be a django.http.HttpResponseRedirect.
*** Performing Custom Actions on Views With Invalid Forms
#+begin_src python
from django.views.generic import CreateView 
from braces.views import LoginRequiredMixin
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView): 
    model = Flavor
    def form_invalid(self, form):
    # Do custom logic here .
        return super(FlavorCreateView, self).form_invalid(form)
#+end_src
*** Using the View Object
If you are using class-based views for rendering content, consider using the view object itself to provide access to properties and methods that can be called by other method and properties.  ey can also be called from templates. For example:
#+begin_src python
from django.utils.functional import cached_property
from django.views.generic import UpdateView, TemplateView
from braces.views import LoginRequiredMixin 
from .models import Flavor
from .tasks import update_users_who_favorited 

class FavoriteMixin(object):
    @cached_property
    def likes_and_favorites(self):
    """Returns a dictionary of likes and favorites""" 
    likes = self.object.likes()
    favorites = self.object.favorites()
    return {
        "likes": likes,
        "favorites": favorites,
        "favorites_count": favorites.count(),
    }
class FlavorUpdateView(LoginRequiredMixin, FavoriteMixin, UpdateView): 
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    def form_valid(self, form): 
        update_users_who_favorited(
            instance=self.object,
            favorites=self.likes_and_favorites['favorites']
        )
        return super(FlavorCreateView, self).form_valid(form)
class FlavorDetailView(LoginRequiredMixin, FavoriteMixin, TemplateView): 
    model = Flavor
#+end_src

The nice thing about this is the various  avors/ app templates can now access this property:
{% raw %}
#+begin_src python
{# flavors/base.html #}
{% extends "base.html" %}

{% block likes_and_favorites %} 
  <ul>
    <li>Likes: {{ view.likes_and_favorites.likes }}</li>
    <li>Favorites: {{ view.likes_and_favorites.favorites_count }}</li> 
  </ul>
{% endblock likes_and_favorites %}
#+end_src
{% endraw %}
** How GCBVs and Forms Fit Together
First, let’s define a flavor model to use in this section’s view examples:
#+begin_src python
# flavors/models.py
from django.core.urlresolvers import reverse 
from django.db import models
STATUS = (
    (0, "zero"),
    (1, "one"),
)

class Flavor(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)
    scoops_remaining = models.IntegerField(default=0, choices=STATUS)
    def get_absolute_url(self):
        return reverse("flavors:detail", kwargs={"slug": self.slug})
#+end_src
*** Views + ModelForm Example
Here we have the following views:
1. FlavorCreateView corresponds to a form for adding new flavors.
2. FlavorUpdateView corresponds to a form for editing existing flavors.
3. FlavorDetailView corresponds to the con rmation page for both  avor creation and flavor updates.
Views:
#+begin_src python
# flavors/views.py
from django.contrib import messages
from django.views.generic import CreateView, UpdateView, DetailView
from braces.views import LoginRequiredMixin 
from .models import Flavor

class FlavorActionMixin(object):
    fields = ('title', 'slug', 'scoops_remaining')
    @property
    def success_msg(self):
        return NotImplemented

    def form_valid(self, form):
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)

class FlavorCreateView(LoginRequiredMixin, FlavorActionMixin, CreateView):
    model = Flavor
    success_msg = "Flavor created!"
class FlavorUpdateView(LoginRequiredMixin, FlavorActionMixin, UpdateView):
    model = Flavor
    success_msg = "Flavor updated!"
class FlavorDetailView(DetailView):
    model = Flavor
#+end_src

Template:
{% raw %}
#+begin_src python
{# templates/flavors/flavor_detail.html #}
{% if messages %}
  <ul class="messages">
    {% for message in messages %}
    <li id="message_{{ forloop.counter }}"
        {% if message.tags %} class="{{ message.tags }}" .
          {% endif %}>
        {{ message }}
    </li>
    {% endfor %} 
  </ul>
{% endif %}
#+end_src
{% endraw %}
*** Views + Form Example
Implemente flavor search page
We add the following code to flavors/views.py:
#+begin_src python
from django.views.generic import ListView
from .models import Flavor

class FlavorListView(ListView): 
    model = Flavor
    def get_queryset(self):
    # Fetch the queryset from the parent get_queryset
        queryset = super(FlavorListView, self).get_queryset()

        # Get the q GET parameter
        q = self.request.GET.get("q") 
        if q:
            # Return a filtered queryset
            return queryset.filter(title__icontains=q) 
        # Return the base queryset
        return queryset
#+end_src

Template:
{% raw %}
#+begin_src python
{# templates/flavors/_flavor_search.html #}
{% comment %}
  Usage: {% include "flavors/_flavor_search.html" %}
{% endcomment %}
<form action="{% url "flavor_list" %}" .method="GET">
  <input type="text" name="q" />
  <button type="submit">search</button> 
</form>
#+end_src
{% endraw %}
** Using Just django.views.generic.View
What we find really useful, even on projects which use a lot of generic class-based views, is using the django.views.generic.View class with a GET method for displaying JSON, PDF or other non-HTML content. All the tricks that we’ve used for rendering CSV, Excel, and PDF  les in function-based views apply when using the GET method. For example:

#+begin_src python
from django.http import HttpResponse .
from django.shortcuts import get_object_or_404
from django.views.generic import View
from braces.views import LoginRequiredMixin
from .models import Flavor
from .reports import make_flavor_pdf

class PDFFlavorView(LoginRequiredMixin, View): 
    # Get the flavor
    def get(self, request, *args, **kwargs):
        flavor = get_object_or_404(Flavor, slug=kwargs['slug'])
        # create the response
        response = HttpResponse(content_type='application/pdf')
        # generate the PDF stream and attach to the response
        response = make_flavor_pdf(response, flavor)
        return response
#+end_src
* Form Fundamentals
** Validate All Incoming Data With Django Forms
舉個input data為csv file的例子
Bad Example: 
#+begin_src python
import csv import StringIO
from .models import Purchase 

def add_csv_purchases(rows):
    rows = StringIO.StringIO(rows)
    records_added = 0
    # Generate a dict per row, with the first CSV row being the keys 
    for row in csv.DictReader(rows, delimiter=","):
        # DON'T DO THIS: Tossing unvalidated data into your model.
        Purchase.objects.create(**row)
        records_added += 1
    return records_added
#+end_src
以上Bad example在Purchase create前需要自己寫input data驗證code

Good Example:
#+begin_src python
import csv import StringIO
from django import forms
from .models import Purchase, Seller 

class PurchaseForm(forms.ModelForm):
    class Meta:
        model = Purchase
    def clean_seller(self):
        seller = self.cleaned_data["seller"] 
        try:
            Seller.objects.get(name=seller) 
        except Seller.DoesNotExist:
            msg = "{0} does not exist in purchase #{1}.".format(
                seller,
                self.cleaned_data["purchase_number"]
            )
        raise forms.ValidationError(msg) return seller

def add_csv_purchases(rows):
    rows = StringIO.StringIO(rows)
    records_added = 0
    errors = []
    # Generate a dict per row, with the first CSV row being the k
    for row in csv.DictReader(rows, delimiter=","):
        # Bind the row data to the PurchaseForm. 
        form = PurchaseForm(row)
        # Check to see if the row data is valid. 
        if form.is_valid():
            # Row data is valid so save the record.
            form.save()
            records_added += 1
        else: 
            errors.append(form.errors)
    return recordded, errors
#+end_src
利用django ModelForm的is_valid來做input驗證
** Always Use CSRF Protection and POST With HTTP Forms That Modify Data
You should use Django’s CsrfViewMiddleware as blanket protection across your site rather than manually decorating views with csrf protect.
You should use Django’s CSRF protection even when posting data via AJAX.
** Understand How to Add Django Form Instance Attributes
Inserting the request.user object into forms
form:
#+begin_src python
from django import forms
from .models import Taster
class TasterForm(forms.ModelForm):
    class Meta:
        model = Taster

    def __init__(self, *args, **kwargs):
        # set the user as an attribute of the form 
        self.user = kwargs.pop('user')
        super(TasterForm, self).__init__(*args, **kwargs)
#+end_src

view:
#+begin_src python
from django.views.generic import UpdateView 
from braces.views import LoginRequiredMixin
from .forms import TasterForm 
from .models import Taster

class TasterUpdateView(LoginRequiredMixin, UpdateView): 
    model = Taster
    form_class = TasterForm
    success_url = "/someplace/"
    def get_form_kwargs(self):
        """This method is what injects forms with their keyword arguments.""" 
        # grab the current set of form #kwargs
        kwargs = super(TasterUpdateView, self).get_form_kwargs()
        # Update the kwargs with the user_id
        kwargs['user'] = self.request.user
        return kwargs
#+end_src
** Know How Form Validation Works
Form validation workflow:
+ If the form has bound data, form.is valid() calls the form.full clean() method.
+ form.fullclean() iterates through the form fields and each field validates itself:
  - Data coming into the  eld is coerced into Python via the to python() method or raises a ValidationError.
  - Data is validated against  eld-speci c rules, including custom validators. Failure raises a ValidationError.
  - If there are any custom clean <field>() methods in the form, they are called at this time.
+ form.fullclean() executes the form.clean() method.
+ If it’s a ModelForm instance, form. post clean() does the following:
  - Sets ModelForm data to the Model instance, regardless of whether form.is valid() is True or False.
  - Calls the model’s clean() method. For reference, saving a model instance through the ORM does not call the model’s clean() method.
*** ModelForm Data Is Saved to the Form, Then the Model In- stance
In a ModelForm, form data is saved in two distinct steps:
1. First, form data is saved to the form instance.
2. Later, form data is saved to the model instance.

For example, perhaps you need to catch the details of failed submission attempts for a form, saving both the user-supplied form data as well as the intended model instance changes.

#+begin_src python
# core/models.py
from django.db import models

class ModelFormFailureHistory(models.Model):
    form_data = models.TextField()
    model_data = models.TextField()
#+end_src

#+begin_src python
# flavors/views.py import json
from django.contrib import messages 
from django.core import serializers
from core.models import ModelFormFailureHistory 

class FlavorActionMixin(object):
    @property
    def success_msg(self):
        return NotImplemented
    def form_valid(self, form):
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)
    def form_invalid(self, form):
        """Save invalid form and model data for later reference.""" 
        form_data = json.dumps(form.cleaned_data)
        model_data = serializers.serialize("json",
                    [form.instance])[1:-1]
        ModelFormFailureHistory.objects.create(
            form_data=form_data,
            model_data=model_data
        )
        return super(FlavorActionMixin, self).form_invalid(form)
#+end_src
** Add Errors to Forms with Form.add error()
We can streamline Form.clean() with the Form.add error() method.
#+begin_src python
from django import forms
class IceCreamReviewForm(forms.Form): 
    # Rest of tester form goes here ...
    def clean(self):
        cleaned_data = super(TasterForm, self).clean()
        flavor = cleaned_data.get("flavor")
        age = cleaned_data.get("age")
        if flavor == 'coffee' and age < 3:
            # Record errors that will be displayed later. 
            msg = u"Coffee Ice Cream is not for Babies." 
            self.add_error('flavor', msg) 
            self.add_error('age', msg)
        # Always return the full collection of cleaned data. 
        return cleaned_data
#+end_src
* Common Patterns for Forms
** Pattern 1: Simple ModelForm With Default Validators
#+begin_src python
# flavors/views.py
from django.views.generic import CreateView, UpdateView
from braces.views import LoginRequiredMixin
from .models import Flavor
class FlavorCreateView(LoginRequiredMixin, CreateView):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
class FlavorUpdateView(LoginRequiredMixin, UpdateView): 
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
#+end_src
+ FlavorCreateView and FlavorUpdateView are assigned Flavor as their model.
+ Both views auto-generate a ModelForm based on the Flavor model.
+ Those ModelForms rely on the default field validation rules of the Flavor model.
** Pattern 2: Custom Form Field Validators in ModelForms
write validator:
#+begin_src python
# core/validators.py
from django.core.exceptions import ValidationError
def validate_tasty(value):
    """Raise a ValidationError if the value doesn't start with the word 'Tasty'."""
    if not value.startswith(u"Tasty"): 
        msg = u"Must start with Tasty" 
        raise ValidationError(msg)
#+end_src
In Django, a custom field validator is simply a function that raises an error if the submitted argument doesn’t pass its test.

validator可以加在兩個地方
*** put validator in Model
#+begin_src python
# core/models.py
from django.db import models
from .validators import validate_tasty 

class TastyTitleAbstractModel(models.Model):
    title = models.CharField(max_length=255, validators=[validate_tasty])
    class Meta: 
        abstract = True
#+end_src
#+begin_src python
# flavors/models.py
from django.core.urlresolvers import reverse 
from django.db import models
from core.models import TastyTitleAbstractModel .

class Flavor(TastyTitleAbstractModel):
    slug = models.SlugField()
    scoops_remaining = models.IntegerField(default=0)
    def get_absolute_url(self):
        return reverse("flavors:detail", kwargs={"slug": self.slug})
#+end_src
*** put validator in Form
#+begin_src python
# flavors/forms.py
from django import forms
from core.validators import validate_tasty from .models import Flavor

class FlavorForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super(FlavorForm, self).__init__(*args, **kwargs)
        self.fields["title"].validators.append(validate_tasty)
        self.fields["slug"].validators.append(validate_tasty)
    class Meta:
        model = Flavor
#+end_src
#+begin_src python
# flavors/views.py
from django.contrib import messages
from django.views.generic import CreateView, UpdateView, DetailView
from braces.views import LoginRequiredMixin 
from .models import Flavor
from .forms import FlavorForm 

class FlavorActionMixin(object):
    model = Flavor
    fields = ('title', 'slug', 'scoops_remaining')
    @property
    def success_msg(self):
        return NotImplemented
    def form_valid(self, form): 
        messages.info(self.request, self.success_msg)
        return super(FlavorActionMixin, self).form_valid(form)
class FlavorCreateView(LoginRequiredMixin, FlavorActionMixin, CreateView):
    success_msg = "created"
    # Explicitly attach the FlavorForm class
    form_class = FlavorForm
class FlavorUpdateView(LoginRequiredMixin, FlavorActionMixin, UpdateView):
    success_msg = "updated"
    # Explicitly attach the FlavorForm class
    form_class = FlavorForm
class FlavorDetailView(DetailView): 
    model = Flavor
#+end_src
* Reference
此筆記大多來自這本書：
Two Scoops of Django: Best Practices for Django 1.8
by Daniel Roy Greenfeld (Author), Audrey Roy Greenfeld (Author)
https://www.twoscoopspress.com/
